# -*- coding: utf-8 -*-
"""Multidimensional-Scaling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F8ALTcx0dK5-qfJwcwpaAsgeTQERTZP3

Я решил рассчитывать свою матрицу расстояний с использованием 1-подобия, где сходство - это матрица оценок психологического сходства.

Вы также можете рассчитать расстояние как 1 / подобие или (1-подобие) / сходство. По сути, расстояние - это противоположность подобия. Было проведено множество исследований, подтверждающих различные способы выполнения расчета расстояния. Но поскольку наш набор данных колеблется на шкале от (-1,1), я решил использовать простейшую и интуитивно понятную меру: 1-подобие.
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

names = ["football", "baseball", "basketball", "tennis","ice hockey","boxing","golf","gymnastics"]

similarities = np.loadtxt(open("sport_similarities", "rb"), delimiter=",", skiprows=1)

print(similarities)


distances = 1-similarities
D = 2
N = distances.shape[0]  # the number of items
assert (distances.shape[1] == N and N == len(names))

# euclidean distance between 2 any given points
def dist(a, b):
    return np.sqrt(np.sum((a - b) ** 2))

def stress(p):
    stress_sum = 0
    for i in np.arange(0, N):
        for j in np.arange(i+1, distances.shape[1]):
            stress_sum += (distances[i,j] - dist(p[i], p[j]))**2
    return stress_sum

# helper function for compute_gradient
def add_delta(p, i, d, delta):
    v = np.array(p)
    v[i, d] += delta
    return v

# gradient descent on each element of p
def compute_gradient(p, i, d, delta):
    return (stress(add_delta(p, i, d, delta)) - stress(add_delta(p, i, d, -delta))) / (2*delta)

def compute_full_gradient(p):
    matrix = []
    for i in np.arange(0,len(p)):
        row = []
        
        for d in np.arange(0,len(p[i])):
            row.append(compute_gradient(p, i, d, .001))
        
        matrix.append(row)

    return np.array(matrix)

def MDS():
    pos = np.random.normal(0.0, 1.0, (N, D))
    print("Original stress: " + str(stress(pos)))

    steps = 0
    stress_list = np.array([])
    iterations = np.array([])
    while (steps <= 300):
        step_size = .001 * compute_full_gradient(pos)
        pos -= step_size
        stress_list = np.append(stress(pos), stress_list)
        iterations = np.append(steps, iterations)

        steps += 1

    print("New stress: " + str(stress(pos)))
    return pos
def plot(pos):
    x_data = np.array([])
    y_data = np.array([])
    
    for i in np.arange(0,len(pos)):
        x_data = np.append(pos[i, 0], x_data)
        y_data = np.append(pos[i, 1], y_data)

    plt.scatter(x_data, y_data)

    for i in np.arange(0,N):
        plt.annotate(names[i], main_pos[i])
main_pos = MDS()
plot(main_pos)

"""Результаты обычно интуитивно понятны. Алгоритм MDS довольно хорошо объединяет группы видов спорта. Например, есть кластер по водным видам спорта: гребля на каноэ, серфинг, плавание. Существует еще один кластер для видов спорта, в которых используются более крупные мячи: баскетбол, софтбол, волейбол и т. Д. Однако в каждой моделировании есть несколько, которые сбиваются с пути, и это, вероятно, связано с тем, что алгоритм находит локальный минимум, а не абсолютный минимум. , который зависит от начального рассеяния."""

def MDS_distances(pos):
    MDS_dist = np.array([])
    for i in np.arange(0,8):
        for j in np.arange(0,8):
            MDS_dist = np.append(dist(pos[i], pos[j]), MDS_dist)
    return MDS_dist
        
flat_distances = np.ravel(distances)
plt.ylim(0,1)
plt.xlim(0,1)
plt.scatter(MDS_distances(main_pos), flat_distances)

"""Этот график рассеяния выглядит довольно плохо, существует относительно небольшая связь между рассчитанными MDS расстояниями и психологическими расстояниями. Опять же, это, вероятно, связано с алгоритмом, работающим с локальными минимумами градиентного спуска."""

# plt.plot(stress_list, iterations)

"""
Этот график показывает резкий спуск в снижении напряжения за 50 итераций. Более 300 не слишком сильно снижают нагрузку на наши графики MDS и поэтому не слишком нужны. Алгоритм не может достичь 0, если не найдет абсолютный минимум при градиентном спуске, что маловероятно при увеличении количества элементов.
"""

def plotting_data(pos):
    x_data = np.array([])
    y_data = np.array([])
    
    for i in np.arange(0,len(pos)):
        x_data = np.append(pos[i, 0], x_data)
        y_data = np.append(pos[i, 1], y_data)
    return [x_data, y_data]

MDS1 = MDS()
MDS1_data = plotting_data(MDS1)
plt.scatter(MDS1_data[0], MDS1_data[1], label='MDS Run 1')
for i in np.arange(0,len(MDS1)):
    plt.annotate(names[i], MDS1[i])
plt.show()

MDS2 = MDS()
MDS2_data = plotting_data(MDS2)
plt.scatter(MDS2_data[0], MDS2_data[1], label='MDS Run 2')
for i in np.arange(0,len(MDS2)):
    plt.annotate(names[i], MDS2[i])
plt.show()

MDS3 = MDS()
MDS3_data = plotting_data(MDS3)
plt.scatter(MDS3_data[0], MDS3_data[1], label='MDS Run 3')
for i in np.arange(0,len(MDS3)):
    plt.annotate(names[i], MDS3[i])
plt.show()

MDS4 = MDS()
MDS4_data = plotting_data(MDS4)
plt.scatter(MDS4_data[0], MDS4_data[1], label='MDS Run 4')
for i in np.arange(0,len(MDS4)):
    plt.annotate(names[i], MDS4[i])
plt.show()

MDS5 = MDS()
MDS5_data = plotting_data(MDS5)
plt.scatter(MDS5_data[0], MDS5_data[1], label='MDS Run 5')
for i in np.arange(0,len(MDS5)):
    plt.annotate(names[i], MDS5[i])
plt.show()

"""Эти сюжеты не все одинаковые. Поскольку все они начинаются с разных начальных позиций, кластеры перемещаются в разные части графика. Поскольку алгоритм MDS просто работает с абсолютными расстояниями, размещение каждой точки смещается при каждом ее запуске, однако расстояния между каждой точкой должны оставаться одинаковыми."""

a = [stress(MDS1), stress(MDS2), stress(MDS3), stress(MDS4), stress(MDS5)]
best = min(a)
optimal = a.index(best)
print(f"The best run was run {optimal}, with resulting stress {best}. The plot is shown again below")
plt.scatter(MDS1_data[0], MDS1_data[1], label='MDS Run 1')
for i in np.arange(0,len(MDS1)):
    plt.annotate(names[i], MDS1[i])
plt.show()
"""Я выбрал «лучший прогон» из 5 прогонов, посчитав, какой прогон дает наименьшее результирующее напряжение, поскольку значение напряжения, по сути, является мерой ошибки."""